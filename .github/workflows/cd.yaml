name: Continuous Deployment to GKE

on:
  push:
    branches:
      - main # Trigger this workflow on pushes to the 'main' branch

env:
  # Your Google Cloud Project ID, retrieved from GitHub Secrets
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }} 
  
  # Your GKE cluster name and zone
  GKE_CLUSTER: iris-cluster 
  GKE_ZONE: us-central1-a 
  
  # Application and image details
  DEPLOYMENT_NAME: iris-api-deployment
  SERVICE_NAME: iris-api-service
  IMAGE_NAME: iris-api
  IMAGE_TAG: latest # Using 'latest' for simplicity; consider ${{ github.sha }} for more specific versions

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest # GitHub-hosted runner

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Action to pull your repository code

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2 # Action to install and configure gcloud CLI
        with:
          project_id: ${{ env.PROJECT_ID }}
          # Authenticate using the service account key stored as a GitHub Secret
          service_account_key: ${{ secrets.GCP_SA_KEY }}

      - name: Authenticate Docker to Google Container Registry
        # Configures Docker to use gcloud as a credential helper for GCR
        run: gcloud auth configure-docker gcr.io

      - name: Build Docker image
        # Builds the Docker image. The '.' means the build context is the current directory,
        # which is the root of your cloned GitHub repo (where Dockerfile, etc., are).
        run: docker build -t gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .

      - name: Push Docker image to GCR
        # Pushes the built image to your Google Container Registry
        run: docker push gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Get GKE credentials
        # Configures kubectl to interact with your GKE cluster
        run: gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} --zone ${{ env.GKE_ZONE }}

      - name: Deploy to GKE
        run: |
          # Use 'sed' to dynamically update the image name in your deployment.yaml.
          # This replaces the placeholder `gcr.io/[YOUR_GCP_PROJECT_ID]/iris-api:latest`
          # with your actual project ID and the chosen image tag.
          # The path `kubernetes/deployment.yaml` is correct because 'kubernetes' is a folder
          # at the root of your GitHub repository.
          sed -i "s|gcr.io/\[YOUR_GCP_PROJECT_ID\]/iris-api:latest|gcr.io/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}|g" kubernetes/deployment.yaml

          # Apply the Kubernetes deployment and service manifests.
          # 'kubectl apply' is idempotent, meaning it will create if not exists,
          # or update if changes are detected.
          kubectl apply -f kubernetes/deployment.yaml
          kubectl apply -f kubernetes/service.yaml

          # Optional: Wait for the deployment to roll out and show its status
          echo "Waiting for deployment rollout to complete..."
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }}

          # Optional: Display service info to confirm external IP
          echo "Service details:"
          kubectl get service ${{ env.SERVICE_NAME }}
